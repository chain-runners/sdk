/* AUTOMATICALLY GENERATED BY `yarn codegen`. DO NOT EDIT. */
/* eslint-disable */

import { GraphQLClient } from 'graphql-request';
import * as Dom from 'graphql-request/dist/types.dom';
import gql from 'graphql-tag';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** DateTime scalar type */
  LuxonDateTime: any;
};

export type AlphaRaffleWinner = {
  __typename?: 'AlphaRaffleWinner';
  discriminator: Scalars['String'];
  id: Scalars['String'];
  username: Scalars['String'];
};

export type Bio = {
  __typename?: 'Bio';
  createdAt: Scalars['LuxonDateTime'];
  id: Scalars['ID'];
  textContent: Array<RichTextBlock>;
  token: Token;
  tokenId: Scalars['Int'];
  updatedAt: Scalars['LuxonDateTime'];
};

export type InlineStyleRange = {
  __typename?: 'InlineStyleRange';
  length: Scalars['Int'];
  offset: Scalars['Int'];
  style: RichTextStyle;
};

export type InlineStyleRangeInput = {
  length: Scalars['Int'];
  offset: Scalars['Int'];
  style: RichTextStyle;
};

export type Mutation = {
  __typename?: 'Mutation';
  claimPOAP: PoapMutationResponse;
  disconnectDiscordAccount: MutationResponse;
  linkDiscordAccount: MutationResponse;
  login: UserLoginResponse;
  logout: MutationResponse;
  refreshToken: RefreshTokenResponse;
  setBioForRunner: MutationResponse;
  syncDiscordRoles: MutationResponse;
};


export type MutationClaimPoapArgs = {
  recaptchaResponse: Scalars['String'];
};


export type MutationLinkDiscordAccountArgs = {
  code: Scalars['String'];
};


export type MutationLoginArgs = {
  input: UserLoginArgs;
};


export type MutationSetBioForRunnerArgs = {
  content: Array<RichTextBlockInput>;
  runnerId: Scalars['Int'];
};

export type MutationResponse = {
  __typename?: 'MutationResponse';
  message: Scalars['String'];
  success: Scalars['Boolean'];
};

export type ObjectProperty = {
  __typename?: 'ObjectProperty';
  name: Scalars['String'];
  type: Scalars['String'];
};

export type PoapCode = {
  __typename?: 'POAPCode';
  code: Scalars['String'];
  createdAt: Scalars['LuxonDateTime'];
  id: Scalars['ID'];
  updatedAt: Scalars['LuxonDateTime'];
  userId?: Maybe<Scalars['String']>;
};

export type PoapMutationResponse = {
  __typename?: 'POAPMutationResponse';
  message: Scalars['String'];
  poap?: Maybe<PoapCode>;
  success: Scalars['Boolean'];
};

export type PaginationArgs = {
  limit: Scalars['Int'];
  offset?: InputMaybe<Scalars['Int']>;
};

export type Query = {
  __typename?: 'Query';
  bioForRunner?: Maybe<Bio>;
  getObjectProperties?: Maybe<Array<ObjectProperty>>;
  getTraitsByDNA: Array<Trait>;
  poapForUser?: Maybe<PoapCode>;
  token?: Maybe<Token>;
  tokens: TokenListResponse;
  trait?: Maybe<Trait>;
  traits: TraitListResponse;
  unclaimedXRTokens: UnclaimedTokenResponse;
  wallet?: Maybe<Wallet>;
  wallets: WalletListResponse;
  whoAmI?: Maybe<User>;
  xrToken?: Maybe<XrToken>;
  xrTokens: XrTokenListResponse;
};


export type QueryBioForRunnerArgs = {
  runnerId: Scalars['Int'];
};


export type QueryGetObjectPropertiesArgs = {
  objectName: Scalars['String'];
};


export type QueryGetTraitsByDnaArgs = {
  dna: Scalars['String'];
};


export type QueryTokenArgs = {
  id: Scalars['ID'];
};


export type QueryTokensArgs = {
  options?: InputMaybe<TokenQueryOptions>;
};


export type QueryTraitArgs = {
  id: Scalars['ID'];
};


export type QueryTraitsArgs = {
  pagination?: InputMaybe<PaginationArgs>;
};


export type QueryUnclaimedXrTokensArgs = {
  address: Scalars['String'];
};


export type QueryWalletArgs = {
  id: Scalars['ID'];
};


export type QueryWalletsArgs = {
  pagination?: InputMaybe<PaginationArgs>;
};


export type QueryXrTokenArgs = {
  id: Scalars['ID'];
};


export type QueryXrTokensArgs = {
  options?: InputMaybe<XrTokenQueryOptions>;
};

export type RefreshTokenResponse = {
  __typename?: 'RefreshTokenResponse';
  message: Scalars['String'];
  success: Scalars['Boolean'];
  token?: Maybe<Scalars['String']>;
};

export type RichTextBlock = {
  __typename?: 'RichTextBlock';
  inlineStyleRanges: Array<InlineStyleRange>;
  text: Scalars['String'];
};

export type RichTextBlockInput = {
  inlineStyleRanges: Array<InlineStyleRangeInput>;
  text: Scalars['String'];
};

export enum RichTextStyle {
  Bold = 'BOLD',
  Italic = 'ITALIC',
  Monospace = 'MONOSPACE',
  Strikethrough = 'STRIKETHROUGH',
  Underline = 'UNDERLINE'
}

export type Token = {
  __typename?: 'Token';
  attributes: Array<TokenAttribute>;
  createdAt: Scalars['LuxonDateTime'];
  dnaString: Scalars['String'];
  id: Scalars['Int'];
  ownerAddress: Scalars['String'];
  rawMetadata: Scalars['String'];
  svg: Scalars['String'];
  traitIds: Array<Scalars['Int']>;
  traits: Array<Trait>;
  updatedAt: Scalars['LuxonDateTime'];
};

export type TokenAttribute = {
  __typename?: 'TokenAttribute';
  createdAt: Scalars['LuxonDateTime'];
  id: Scalars['ID'];
  token: Token;
  tokenId: Scalars['Int'];
  trait: Trait;
  traitId: Scalars['String'];
  updatedAt: Scalars['LuxonDateTime'];
};

export type TokenFilters = {
  ownedBy?: InputMaybe<Scalars['String']>;
  traits?: InputMaybe<Array<TokenTraitFilter>>;
  withBioOnly?: InputMaybe<Scalars['Boolean']>;
};

export type TokenListResponse = {
  __typename?: 'TokenListResponse';
  count: Scalars['Float'];
  records: Array<Token>;
};

export type TokenQueryOptions = {
  filters?: InputMaybe<TokenFilters>;
  pagination?: InputMaybe<PaginationArgs>;
};

export type TokenTraitFilter = {
  traitType: TraitType;
  values: Array<Scalars['String']>;
};

export type Trait = {
  __typename?: 'Trait';
  displayName: Scalars['String'];
  id: Scalars['Int'];
  name: Scalars['String'];
  svgContent: Scalars['String'];
  tokenCount: Scalars['Int'];
  traitIndex: Scalars['Int'];
  type: TraitType;
};

export type TraitListResponse = {
  __typename?: 'TraitListResponse';
  count: Scalars['Float'];
  records: Array<Trait>;
};

export enum TraitType {
  Background = 'Background',
  EarAccessory = 'EarAccessory',
  EyeAccessory = 'EyeAccessory',
  Eyes = 'Eyes',
  Face = 'Face',
  FaceAccessory = 'FaceAccessory',
  HeadAbove = 'HeadAbove',
  HeadBelow = 'HeadBelow',
  Mask = 'Mask',
  Mouth = 'Mouth',
  MouthAccessory = 'MouthAccessory',
  Nose = 'Nose',
  Race = 'Race'
}

export type UnclaimedTokenResponse = {
  __typename?: 'UnclaimedTokenResponse';
  count: Scalars['Int'];
  tokenIds: Array<Scalars['Int']>;
};

export type User = {
  __typename?: 'User';
  address: Scalars['String'];
  createdAt: Scalars['LuxonDateTime'];
  discordAccountId?: Maybe<Scalars['String']>;
  discordAccountName?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  role: UserRole;
  updatedAt: Scalars['LuxonDateTime'];
};

export type UserLoginArgs = {
  address: Scalars['String'];
  signature: Scalars['String'];
};

export type UserLoginResponse = {
  __typename?: 'UserLoginResponse';
  message: Scalars['String'];
  success: Scalars['Boolean'];
  token?: Maybe<Scalars['String']>;
  user?: Maybe<User>;
};

export enum UserRole {
  SuperAdmin = 'SuperAdmin',
  User = 'User'
}

export type Wallet = {
  __typename?: 'Wallet';
  createdAt: Scalars['LuxonDateTime'];
  id: Scalars['String'];
  updatedAt: Scalars['LuxonDateTime'];
};

export type WalletListResponse = {
  __typename?: 'WalletListResponse';
  count: Scalars['Float'];
  records: Array<Wallet>;
};

export type XrToken = {
  __typename?: 'XRToken';
  attributes: Array<XrTokenAttribute>;
  createdAt: Scalars['LuxonDateTime'];
  dnaString: Scalars['String'];
  id: Scalars['Int'];
  ownerAddress: Scalars['String'];
  rawMetadata: Scalars['String'];
  svg: Scalars['String'];
  traitIds: Array<Scalars['Int']>;
  traits: Array<Trait>;
  updatedAt: Scalars['LuxonDateTime'];
};

export type XrTokenAttribute = {
  __typename?: 'XRTokenAttribute';
  createdAt: Scalars['LuxonDateTime'];
  id: Scalars['ID'];
  token: XrToken;
  tokenId: Scalars['Int'];
  trait: Trait;
  traitId: Scalars['String'];
  updatedAt: Scalars['LuxonDateTime'];
};

export type XrTokenFilters = {
  ownedBy?: InputMaybe<Scalars['String']>;
  traits?: InputMaybe<Array<XrTokenTraitFilter>>;
  withBioOnly?: InputMaybe<Scalars['Boolean']>;
};

export type XrTokenListResponse = {
  __typename?: 'XRTokenListResponse';
  count: Scalars['Float'];
  records: Array<XrToken>;
};

export type XrTokenQueryOptions = {
  filters?: InputMaybe<XrTokenFilters>;
  pagination?: InputMaybe<PaginationArgs>;
};

export type XrTokenTraitFilter = {
  traitType: TraitType;
  values: Array<Scalars['String']>;
};

export type RunnerFragment = { __typename: 'Token', id: number, ownerAddress: string, dnaString: string, traitIds: Array<number>, updatedAt: any, createdAt: any };

export type TraitFragment = { __typename: 'Trait', id: number, name: string, displayName: string, type: TraitType, traitIndex: number, tokenCount: number };

export type XrRunnerFragment = { __typename: 'XRToken', id: number, ownerAddress: string, dnaString: string, traitIds: Array<number>, updatedAt: any, createdAt: any };

export type GetAllTraitsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAllTraitsQuery = { __typename?: 'Query', traits: { __typename?: 'TraitListResponse', count: number, records: Array<{ __typename: 'Trait', id: number, name: string, displayName: string, type: TraitType, traitIndex: number, tokenCount: number }> } };

export type GetBioForRunnerQueryVariables = Exact<{
  runnerId: Scalars['Int'];
}>;


export type GetBioForRunnerQuery = { __typename?: 'Query', bioForRunner?: { __typename?: 'Bio', textContent: Array<{ __typename?: 'RichTextBlock', text: string, inlineStyleRanges: Array<{ __typename?: 'InlineStyleRange', length: number, style: RichTextStyle, offset: number }> }> } | null | undefined };

export type GetRunnerByIdQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type GetRunnerByIdQuery = { __typename?: 'Query', token?: { __typename: 'Token', id: number, ownerAddress: string, dnaString: string, traitIds: Array<number>, updatedAt: any, createdAt: any } | null | undefined };

export type GetRunnersQueryVariables = Exact<{
  options?: InputMaybe<TokenQueryOptions>;
}>;


export type GetRunnersQuery = { __typename?: 'Query', tokens: { __typename?: 'TokenListResponse', count: number, records: Array<{ __typename: 'Token', id: number, ownerAddress: string, dnaString: string, traitIds: Array<number>, updatedAt: any, createdAt: any }> } };

export type GetRunnersByOwnerQueryVariables = Exact<{
  owner: Scalars['String'];
}>;


export type GetRunnersByOwnerQuery = { __typename?: 'Query', tokens: { __typename?: 'TokenListResponse', count: number, records: Array<{ __typename: 'Token', id: number, ownerAddress: string, dnaString: string, traitIds: Array<number>, updatedAt: any, createdAt: any }> }, xrTokens: { __typename?: 'XRTokenListResponse', count: number, records: Array<{ __typename: 'XRToken', id: number, ownerAddress: string, dnaString: string, traitIds: Array<number>, updatedAt: any, createdAt: any }> } };

export type GetXrRunnerByIdQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type GetXrRunnerByIdQuery = { __typename?: 'Query', xrToken?: { __typename: 'XRToken', id: number, ownerAddress: string, dnaString: string, traitIds: Array<number>, updatedAt: any, createdAt: any } | null | undefined };

export type GetXrRunnersQueryVariables = Exact<{
  options?: InputMaybe<XrTokenQueryOptions>;
}>;


export type GetXrRunnersQuery = { __typename?: 'Query', xrTokens: { __typename?: 'XRTokenListResponse', count: number, records: Array<{ __typename: 'XRToken', id: number, ownerAddress: string, dnaString: string, traitIds: Array<number>, updatedAt: any, createdAt: any }> } };

export const RunnerFragmentDoc = gql`
    fragment runner on Token {
  __typename
  id
  ownerAddress
  dnaString
  traitIds
  updatedAt
  createdAt
}
    `;
export const TraitFragmentDoc = gql`
    fragment trait on Trait {
  __typename
  id
  name
  displayName
  type
  traitIndex
  tokenCount
}
    `;
export const XrRunnerFragmentDoc = gql`
    fragment xrRunner on XRToken {
  __typename
  id
  ownerAddress
  dnaString
  traitIds
  updatedAt
  createdAt
}
    `;
export const GetAllTraitsDocument = gql`
    query getAllTraits {
  traits {
    records {
      ...trait
    }
    count
  }
}
    ${TraitFragmentDoc}`;
export const GetBioForRunnerDocument = gql`
    query getBioForRunner($runnerId: Int!) {
  bioForRunner(runnerId: $runnerId) {
    textContent {
      text
      inlineStyleRanges {
        length
        style
        offset
      }
    }
  }
}
    `;
export const GetRunnerByIdDocument = gql`
    query getRunnerById($id: ID!) {
  token(id: $id) {
    ...runner
  }
}
    ${RunnerFragmentDoc}`;
export const GetRunnersDocument = gql`
    query getRunners($options: TokenQueryOptions) {
  tokens(options: $options) {
    count
    records {
      ...runner
    }
  }
}
    ${RunnerFragmentDoc}`;
export const GetRunnersByOwnerDocument = gql`
    query getRunnersByOwner($owner: String!) {
  tokens(options: {filters: {ownedBy: $owner}}) {
    count
    records {
      ...runner
    }
  }
  xrTokens(options: {filters: {ownedBy: $owner}}) {
    count
    records {
      ...xrRunner
    }
  }
}
    ${RunnerFragmentDoc}
${XrRunnerFragmentDoc}`;
export const GetXrRunnerByIdDocument = gql`
    query getXRRunnerById($id: ID!) {
  xrToken(id: $id) {
    ...xrRunner
  }
}
    ${XrRunnerFragmentDoc}`;
export const GetXrRunnersDocument = gql`
    query getXRRunners($options: XRTokenQueryOptions) {
  xrTokens(options: $options) {
    count
    records {
      ...xrRunner
    }
  }
}
    ${XrRunnerFragmentDoc}`;

export type SdkFunctionWrapper = <T>(action: (requestHeaders?:Record<string, string>) => Promise<T>, operationName: string) => Promise<T>;


const defaultWrapper: SdkFunctionWrapper = (action, _operationName) => action();

export function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {
  return {
    getAllTraits(variables?: GetAllTraitsQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetAllTraitsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetAllTraitsQuery>(GetAllTraitsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getAllTraits');
    },
    getBioForRunner(variables: GetBioForRunnerQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetBioForRunnerQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetBioForRunnerQuery>(GetBioForRunnerDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getBioForRunner');
    },
    getRunnerById(variables: GetRunnerByIdQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetRunnerByIdQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetRunnerByIdQuery>(GetRunnerByIdDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getRunnerById');
    },
    getRunners(variables?: GetRunnersQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetRunnersQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetRunnersQuery>(GetRunnersDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getRunners');
    },
    getRunnersByOwner(variables: GetRunnersByOwnerQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetRunnersByOwnerQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetRunnersByOwnerQuery>(GetRunnersByOwnerDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getRunnersByOwner');
    },
    getXRRunnerById(variables: GetXrRunnerByIdQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetXrRunnerByIdQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetXrRunnerByIdQuery>(GetXrRunnerByIdDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getXRRunnerById');
    },
    getXRRunners(variables?: GetXrRunnersQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetXrRunnersQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetXrRunnersQuery>(GetXrRunnersDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getXRRunners');
    }
  };
}
export type Sdk = ReturnType<typeof getSdk>;